// Copyright 2011 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


#include "failed_commands_script.h"
#include "graph.h"

#include <stdio.h>
#include <errno.h>
#include <assert.h>

namespace {

static bool Write(FILE* file, const void* ptr, size_t size, size_t nitems,
                  string* err) {
  assert(file);
  size_t written_nitems = fwrite(ptr, size, nitems, file);
  if (written_nitems < nitems) {
    if (err)
      *err = strerror(errno);
    return false;
  }
  return true;
}

static bool Write(FILE* file, const char* str, string* err) {
  return Write(file, str, sizeof(char), strlen(str), err);
}

static bool Write(FILE* file, const string& str, string* err) {
  return Write(file, str.c_str(), err);
}

static bool Writeln(FILE* file, const void* ptr, size_t size, size_t nitems,
                    string* err) {
  return Write(file, ptr, size, nitems, err) && Write(file, "\n", err);
}

static bool Writeln(FILE* file, const char* str, string* err) {
  return Writeln(file, str, sizeof(char), strlen(str), err);
}

static bool Writeln(FILE* file, const string& str, string* err) {
  return Writeln(file, str.c_str(), err);
}

static bool WriteHeader(FILE* file, string* err) {
  assert(file);
  const char* header = \
    "#!/bin/sh\n"
    "# Script generated by Ninja.\n"
    "# Execute it to re-run failed commands of last build.\n"
    "# You can also hack it to debug command line.\n"
    "\n"
    "# Tell the shell to exit after the first command failed.\n"
    "set -e\n"
    "\n";
  return Write(file, header, sizeof(char), strlen(header), err);
}

static bool WriteFooter(FILE* file, string* err) {
  assert(file);
  const char* footer = \
    "# end of file\n"
    ;
  return Write(file, footer, sizeof(char), strlen(footer), err);
}

static bool WriteComment(FILE* file,
                         const string& str,
                         unsigned indent_level,
                         string* err) {
 if (!Write(file, "# ", err))
   return false;
 for (unsigned i = 0; i < indent_level; ++i) {
   if (!Write(file, "  ", err))
     return false;
 }
 return Write(file, str, err) && Write(file, "\n", err);
}

static bool WriteEdge(FILE* file, Edge* edge, string* err) {
  assert(file);
  assert(edge);
  // Write rule:
  if (!WriteComment(file, "rule: " + edge->rule_->name(), 0, err))
    return false;
  // Write description
  if (!WriteComment(file, "description:", 0, err))
    return false;
  if (!WriteComment(file, edge->GetBinding("description"), 1, err))
    return false;
  // Write inputs
  if (!WriteComment(file, "inputs:", 0, err))
    return false;
  for (vector<Node*>::const_iterator i = edge->inputs_.begin();
       i != edge->inputs_.end() && *i != NULL; ++i) {
    if (!WriteComment(file, (*i)->path(), 1, err))
      return false;
  }
  // Write outputs
  if (!WriteComment(file, "outputs:", 0, err))
    return false;
  for (vector<Node*>::const_iterator i = edge->outputs_.begin();
       i != edge->outputs_.end() && *i != NULL; ++i) {
    if (!WriteComment(file, (*i)->path(), 1, err))
      return false;
  }
  // Write command.
  if (!Writeln(file, edge->EvaluateCommand() + "\n", err))
    return false;
  return true;
}

} // anonymous namespace

bool WriteFailedCommandsScript(const string& path,
                               const vector<Edge*>& failed_edges,
                               string* err) {
  FILE* file = fopen(path.c_str(), "wb");
  if (!file) {
    if (err)
      *err = strerror(errno);
    return false;
  }

  if (!WriteHeader(file, err))
    return false;

  for (vector<Edge*>::const_iterator i = failed_edges.begin();
       i != failed_edges.end();
       ++i) {
    if (!WriteEdge(file, *i, err))
      return false;
  }

  if (!WriteFooter(file, err))
    return false;

  if (fclose(file) != 0) {
    if (err)
      *err = strerror(errno);
    return false;
  }

  return true;
}
